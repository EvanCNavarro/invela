1. Unified API Endpoint Structure
Instead of different endpoints per form type, we use a single, RESTful pattern:

POST /api/tasks/:taskId/submit
The form type is passed in the request body, making this endpoint handle ALL form submissions through a uniform interface.

2. Standardized FormSubmissionService
/**
 * Universal Form Submission Service
 * 
 * Handles submissions for ALL form types through a single standardized interface
 * with no form-type-specific code paths.
 */
export const formSubmissionService = {
  submitForm: async (options: SubmissionOptions): Promise<SubmissionResult> => {
    const { taskId, formType, formData } = options;
    
    // Show standard loading toast
    toastService.showLoading(`Processing submission...`);
    
    try {
      // Always use the unified endpoint for all form types
      const response = await fetch(`/api/tasks/${taskId}/submit`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          formType,
          formData,
          timestamp: new Date().toISOString()
        })
      });
      
      // Standard error handling
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
        throw new Error(errorData.error || 'Submission failed');
      }
      
      // Standard success handling
      const result = await response.json();
      
      // Clear loading toast and show success toast
      toastService.clearAll();
      toastService.showSuccess('Form submitted successfully');
      
      // Show standard success modal
      modalService.showSuccessModal({
        title: "Submission Successful",
        description: result.details || "Your form has been successfully submitted.",
        actions: formatSuccessActions(result),
        onClose: () => {
          // Standard post-submission callback
          if (options.onSuccess) options.onSuccess(result);
        }
      });
      
      return {
        success: true,
        taskId,
        formType,
        status: 'submitted',
        ...result
      };
    } catch (error) {
      // Standard error handling
      toastService.clearAll();
      toastService.showError(`Submission failed: ${error.message}`);
      
      if (options.onError) options.onError(error);
      
      return {
        success: false,
        taskId,
        formType,
        status: 'error',
        error: error.message
      };
    }
  }
};
3. Universal Form Component
/**
 * Universal form submission handler that works identically for ALL form types
 */
const handleSubmit = async (data: Record<string, any>) => {
  if (isSubmitting) return;
  
  setSubmissionState({
    isSubmitting: true,
    submitText: "Processing...",
    showSpinner: true
  });
  
  try {
    // Use the universal submission service
    const result = await formSubmissionService.submitForm({
      taskId,
      formType: taskType,
      formData: data,
      onSuccess: () => {
        // Update UI to submitted state
        setSubmissionState({
          isSubmitting: false,
          submitText: "Submitted",
          showSpinner: false
        });
        
        // Call parent onSubmit if provided
        if (onSubmit) onSubmit(data);
      },
      onError: () => {
        // Reset UI to pre-submission state
        setSubmissionState({
          isSubmitting: false,
          submitText: "Submit",
          showSpinner: false
        });
      }
    });
  } catch (error) {
    // Error handling (should never reach here with proper service design)
    setSubmissionState({
      isSubmitting: false,
      submitText: "Submit",
      showSpinner: false
    });
  }
};
4. Universal Server-Side Handler
/**
 * Universal form submission endpoint that handles ALL form types
 * with no special-case code paths per form type.
 */
router.post('/api/tasks/:taskId/submit', requireAuth, async (req, res) => {
  try {
    const taskId = parseInt(req.params.taskId);
    const { formType, formData } = req.body;
    
    // Standard task validation for all form types
    const task = await validateTaskAccess(taskId, req.user);
    if (!task) {
      return res.status(403).json({
        success: false,
        error: 'Access denied or task not found'
      });
    }
    
    // Standardized submission processing
    const result = await processFormSubmission(task, formType, formData, req.user);
    
    // Standardized success response for all form types
    return res.status(200).json({
      success: true,
      taskId,
      formType,
      status: 'submitted',
      fileId: result.fileId,
      fileName: result.fileName,
      details: result.details,
      unlockedTabs: result.unlockedTabs,
      unlockedTasks: result.unlockedTasks
    });
  } catch (error) {
    // Standardized error response for all form types
    return res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : 'Submission failed'
    });
  }
});
/**
 * Universal form submission processor that works for all form types
 */
async function processFormSubmission(task, formType, formData, user) {
  // Use the FormProcessor factory to get the right processor
  const processor = FormProcessorFactory.getProcessor(formType);
  
  // Process the form data using the appropriate processor
  const processingResult = await processor.process(task, formData, user);
  
  // Update task status to submitted
  await updateTaskStatus(task.id, 'submitted');
  
  // Create the file with the form data
  const fileResult = await createSubmissionFile(task, formType, formData, user);
  
  // Unlock dependent tasks and tabs
  const unlockResult = await unlockDependentItems(task, formType);
  
  // Broadcast task update via WebSocket
  await broadcastTaskUpdate(task.id);
  
  // Return standardized result
  return {
    fileId: fileResult.fileId,
    fileName: fileResult.fileName,
    details: `Your ${formType.toUpperCase()} form has been successfully submitted.`,
    unlockedTabs: unlockResult.unlockedTabs,
    unlockedTasks: unlockResult.unlockedTasks
  };
}
5. Form Processor Factory (Abstraction for Form-Type Differences)
/**
 * Factory that provides the appropriate form processor
 * while maintaining a uniform interface
 */
class FormProcessorFactory {
  static getProcessor(formType: string): FormProcessor {
    switch (formType) {
      case 'kyb':
        return new KybFormProcessor();
      case 'ky3p':
        return new Ky3pFormProcessor();
      case 'open_banking':
        return new OpenBankingFormProcessor();
      default:
        throw new Error(`Unsupported form type: ${formType}`);
    }
  }
}
/**
 * Base interface for all form processors
 */
interface FormProcessor {
  process(task: any, formData: any, user: any): Promise<ProcessResult>;
}
/**
 * Concrete implementation for KYB forms
 */
class KybFormProcessor implements FormProcessor {
  async process(task, formData, user) {
    // KYB-specific processing
    return { /* standard result */ };
  }
}
/**
 * Concrete implementation for KY3P forms
 */
class Ky3pFormProcessor implements FormProcessor {
  async process(task, formData, user) {
    // KY3P-specific processing
    return { /* standard result */ };
  }
}
/**
 * Concrete implementation for Open Banking forms
 */
class OpenBankingFormProcessor implements FormProcessor {
  async process(task, formData, user) {
    // Open Banking-specific processing
    return { /* standard result */ };
  }
}
Benefits of This Truly Universal Approach:
Same Code Path for ALL Forms: Every form type follows exactly the same code path with no special cases

Single Source of Truth: One endpoint, one service, one universal flow

Polymorphic Behavior Through Abstraction: Form-specific differences are encapsulated in processor classes that share a uniform interface

Future-Proof: Adding a new form type requires only adding a new processor implementation

Consistent UX: Users experience the exact same submission flow regardless of form type

Maintenance Simplicity: Changes to the submission process can be made in one place

Testability: The standardized interface makes it easy to write tests that verify all form types