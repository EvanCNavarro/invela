OODA Approach for Unified Form Submission Process
After auditing the codebase, I've found that we need a comprehensive transaction-based approach to form submissions, similar to what's working well in the "Invite a new fintech" process. Let me propose a solution using the OODA (Observe, Orient, Decide, Act) framework:

Observe: Current Implementation Issues
Form submission operations are not wrapped in transactions, causing potential inconsistencies if one step fails
Different form types have similar but separate code paths with duplicated logic
Logging is inconsistent across different submission handlers
Error handling varies between implementations
Orient: Successful Patterns to Apply
The "Invite a new fintech" process uses a transaction-based approach that works well because:

It wraps all database operations in a single transaction
It uses comprehensive logging with consistent namespace context
It employs a step-by-step process with clear error boundaries
It broadcasts updates only after successful completion
Decide: Implementation Approach
I propose creating a unified transaction-based form submission service that:

Uses database transactions to ensure atomic operations
Follows the DRY (Don't Repeat Yourself) principle for common form submission logic
Incorporates KISS (Keep It Simple, Stupid) by having a clear, linear flow
Includes consistent logger usage with appropriate namespacing
Act: Proposed Solution
/**
 * Unified Form Submission Service
 * 
 * This service provides a transaction-based approach to form submissions
 * that ensures consistency across all form types while supporting type-specific
 * post-submission logic in an atomic, all-or-nothing manner.
 */
import { db } from '@db';
import { tasks, files, companies } from '@db/schema';
import { eq, and } from 'drizzle-orm';
import { logger } from '../utils/logger';
import * as WebSocketService from '../services/websocket';
import { FileCreationService } from '../services/file-creation';
// Configure logger namespace for this service
const log = logger.child({ namespace: 'UnifiedFormSubmissionService' });
// Define supported form types
export type FormType = 'kyb' | 'company_kyb' | 'ky3p' | 'sp_ky3p_assessment' | 'open_banking';
// Define form submission result
export interface FormSubmissionResult {
  success: boolean;
  fileId?: number;
  fileName?: string;
  unlockedTabs: string[];
  error?: string;
}
// Form type specific post-submission handlers
const formTypeHandlers = {
  'kyb': handleKybPostSubmission,
  'company_kyb': handleKybPostSubmission,
  'ky3p': handleKy3pPostSubmission,
  'sp_ky3p_assessment': handleKy3pPostSubmission,
  'open_banking': handleOpenBankingPostSubmission
};
/**
 * Submit a form with transaction-based consistency
 */
export async function submitForm(
  taskId: number,
  formData: Record<string, any>,
  formType: FormType,
  userId: number,
  fileName?: string
): Promise<FormSubmissionResult> {
  log.info('Starting unified form submission process', {
    taskId,
    formType,
    userId,
    fieldCount: Object.keys(formData).length
  });
  
  try {
    // Execute the entire submission process in a transaction
    return await db.transaction(async (trx) => {
      log.info('Starting form submission transaction', { taskId, formType });
      
      // 1. Retrieve task and validate
      const [task] = await trx.select()
        .from(tasks)
        .where(eq(tasks.id, taskId));
      
      if (!task) {
        throw new Error(`Task ${taskId} not found`);
      }
      
      log.info('Retrieved task for submission', { 
        taskId, 
        companyId: task.company_id,
        currentStatus: task.status,
        currentProgress: task.progress
      });
      
      // 2. Create file from form data
      const fileResult = await createFormFile(trx, taskId, task.company_id, formData, formType, userId, fileName);
      
      log.info('Created form file', { 
        taskId, 
        fileId: fileResult.fileId,
        fileName: fileResult.fileName
      });
      
      // 3. Update task status to submitted with 100% progress
      await trx.update(tasks)
        .set({
          status: 'submitted',
          progress: 100,
          completion_date: new Date(),
          updated_at: new Date(),
          metadata: {
            ...task.metadata,
            submission_date: new Date().toISOString(),
            submitted_by: userId,
            file_id: fileResult.fileId,
            file_name: fileResult.fileName
          }
        })
        .where(eq(tasks.id, taskId));
      
      log.info('Updated task status to submitted', { taskId });
      
      // 4. Persist form responses (implementation varies by form type)
      await persistFormResponses(trx, taskId, formData, formType);
      
      log.info('Persisted form responses', { taskId, formType });
      
      // 5. Execute form-specific post-submission logic
      const handler = formTypeHandlers[formType];
      if (!handler) {
        throw new Error(`No handler found for form type: ${formType}`);
      }
      
      const unlockedTabs = await handler(trx, task.id, task.company_id, formData);
      
      log.info('Executed form-specific post-submission logic', {
        taskId,
        formType,
        unlockedTabs
      });
      
      // Return success result
      return {
        success: true,
        fileId: fileResult.fileId,
        fileName: fileResult.fileName,
        unlockedTabs
      };
    });
  } catch (error) {
    // Log the error with full context
    log.error('Form submission failed', {
      taskId,
      formType,
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined
    });
    
    // Return failure result
    return {
      success: false,
      unlockedTabs: [],
      error: error instanceof Error ? error.message : String(error)
    };
  }
}
/**
 * Handle KYB-specific post-submission logic
 * - Unlocks File Vault tab
 */
async function handleKybPostSubmission(
  trx: any,
  taskId: number,
  companyId: number,
  formData: Record<string, any>
): Promise<string[]> {
  const log = logger.child({ namespace: 'KybPostSubmission' });
  
  log.info('Processing KYB post-submission logic', { taskId, companyId });
  
  // Unlock File Vault tab
  await unlockTabForCompany(trx, companyId, 'file-vault');
  
  // Unlock dependent security tasks if any
  await unlockDependentTasks(trx, companyId);
  
  log.info('KYB post-submission completed successfully', { 
    taskId, 
    companyId,
    unlockedTabs: ['file-vault']
  });
  
  return ['file-vault'];
}
/**
 * Handle KY3P-specific post-submission logic
 * - No tabs are unlocked
 */
async function handleKy3pPostSubmission(
  trx: any,
  taskId: number,
  companyId: number,
  formData: Record<string, any>
): Promise<string[]> {
  const log = logger.child({ namespace: 'Ky3pPostSubmission' });
  
  log.info('Processing KY3P post-submission logic', { taskId, companyId });
  log.info('KY3P post-submission completed (no tabs to unlock)', { taskId });
  
  // KY3P doesn't unlock any tabs
  return [];
}
/**
 * Handle Open Banking-specific post-submission logic
 * - Unlocks Dashboard and Insights tabs
 * - Updates company onboarding status
 * - Generates risk score
 * - Updates accreditation status
 */
async function handleOpenBankingPostSubmission(
  trx: any,
  taskId: number,
  companyId: number,
  formData: Record<string, any>
): Promise<string[]> {
  const log = logger.child({ namespace: 'OpenBankingPostSubmission' });
  
  log.info('Processing Open Banking post-submission logic', { taskId, companyId });
  
  // Unlock Dashboard and Insights tabs
  await unlockTabForCompany(trx, companyId, 'dashboard');
  await unlockTabForCompany(trx, companyId, 'insights');
  
  // Mark company onboarding as completed
  await trx.update(companies)
    .set({
      onboarding_completed: true,
      onboarding_completed_at: new Date()
    })
    .where(eq(companies.id, companyId));
  
  log.info('Updated company onboarding status', { companyId });
  
  // Generate risk score based on survey responses
  const riskScore = await generateRiskScore(trx, taskId, formData);
  
  log.info('Generated risk score', { taskId, companyId, riskScore });
  
  // Update accreditation status
  await trx.update(companies)
    .set({
      accreditation_status: 'validated',
      risk_score: riskScore
    })
    .where(eq(companies.id, companyId));
  
  log.info('Updated accreditation status', { companyId });
  
  log.info('Open Banking post-submission completed successfully', {
    taskId,
    companyId,
    unlockedTabs: ['dashboard', 'insights']
  });
  
  return ['dashboard', 'insights'];
}
// Utility functions used by the handlers
/**
 * Unlock a tab for a company
 */
async function unlockTabForCompany(trx: any, companyId: number, tabName: string): Promise<void> {
  const log = logger.child({ namespace: 'UnlockTab' });
  
  log.info('Unlocking tab for company', { companyId, tabName });
  
  await trx.execute(sql`
    UPDATE companies
    SET tabs = CASE
      WHEN ${tabName} = ANY(tabs) THEN tabs
      ELSE array_append(tabs, ${tabName})
    END
    WHERE id = ${companyId}
  `);
}
/**
 * Broadcast form submission results to connected clients
 */
export async function broadcastFormSubmissionResult(result: FormSubmissionResult, taskId: number, formType: FormType, companyId: number): Promise<void> {
  const log = logger.child({ namespace: 'BroadcastSubmission' });
  
  if (result.success) {
    log.info('Broadcasting successful form submission', {
      taskId,
      formType,
      fileId: result.fileId,
      unlockedTabs: result.unlockedTabs
    });
    
    // Broadcast task update
    await WebSocketService.broadcastTaskUpdate(taskId, 'submitted', 100);
    
    // Broadcast file creation if a file was created
    if (result.fileId) {
      await WebSocketService.broadcast('file_created', {
        fileId: result.fileId,
        taskId,
        fileName: result.fileName
      });
    }
    
    // Broadcast form submission completed
    await WebSocketService.broadcastFormSubmission({
      taskId,
      formType,
      status: 'success',
      companyId,
      fileId: result.fileId,
      fileName: result.fileName,
      unlockedTabs: result.unlockedTabs
    });
    
    // If tabs were unlocked, broadcast company tabs update
    if (result.unlockedTabs.length > 0) {
      await WebSocketService.broadcast('company_tabs_updated', {
        companyId,
        unlockedTabs: result.unlockedTabs
      });
    }
  } else {
    log.error('Broadcasting form submission failure', {
      taskId,
      formType,
      error: result.error
    });
    
    // Broadcast form submission failed
    await WebSocketService.broadcastFormSubmission({
      taskId,
      formType,
      status: 'error',
      companyId,
      error: result.error
    });
  }
}
Key Benefits of This Approach
Transaction-Based Consistency: All database operations are wrapped in a transaction, ensuring they all succeed or fail together
Single Responsibility Principle: Each handler focuses on its specific form type's post-submission logic
DRY Implementation: Common functionality is extracted to utility functions
Comprehensive Logging: Consistent logging with namespace context for better troubleshooting
Fail-Fast with Clear Errors: Errors are caught and handled at each step
Explicit Type Safety: TypeScript types for form types and results
Centralized WebSocket Broadcasting: Notifications are only sent after successful transaction completion